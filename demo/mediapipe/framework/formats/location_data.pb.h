// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/framework/formats/location_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mediapipe/framework/formats/annotation/rasterization.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto;
namespace mediapipe {
class LocationData;
struct LocationDataDefaultTypeInternal;
extern LocationDataDefaultTypeInternal _LocationData_default_instance_;
class LocationData_BinaryMask;
struct LocationData_BinaryMaskDefaultTypeInternal;
extern LocationData_BinaryMaskDefaultTypeInternal _LocationData_BinaryMask_default_instance_;
class LocationData_BoundingBox;
struct LocationData_BoundingBoxDefaultTypeInternal;
extern LocationData_BoundingBoxDefaultTypeInternal _LocationData_BoundingBox_default_instance_;
class LocationData_RelativeBoundingBox;
struct LocationData_RelativeBoundingBoxDefaultTypeInternal;
extern LocationData_RelativeBoundingBoxDefaultTypeInternal _LocationData_RelativeBoundingBox_default_instance_;
class LocationData_RelativeKeypoint;
struct LocationData_RelativeKeypointDefaultTypeInternal;
extern LocationData_RelativeKeypointDefaultTypeInternal _LocationData_RelativeKeypoint_default_instance_;
}  // namespace mediapipe
PROTOBUF_NAMESPACE_OPEN
template<> ::mediapipe::LocationData* Arena::CreateMaybeMessage<::mediapipe::LocationData>(Arena*);
template<> ::mediapipe::LocationData_BinaryMask* Arena::CreateMaybeMessage<::mediapipe::LocationData_BinaryMask>(Arena*);
template<> ::mediapipe::LocationData_BoundingBox* Arena::CreateMaybeMessage<::mediapipe::LocationData_BoundingBox>(Arena*);
template<> ::mediapipe::LocationData_RelativeBoundingBox* Arena::CreateMaybeMessage<::mediapipe::LocationData_RelativeBoundingBox>(Arena*);
template<> ::mediapipe::LocationData_RelativeKeypoint* Arena::CreateMaybeMessage<::mediapipe::LocationData_RelativeKeypoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mediapipe {

enum LocationData_Format : int {
  LocationData_Format_GLOBAL = 0,
  LocationData_Format_BOUNDING_BOX = 1,
  LocationData_Format_RELATIVE_BOUNDING_BOX = 2,
  LocationData_Format_MASK = 3
};
bool LocationData_Format_IsValid(int value);
constexpr LocationData_Format LocationData_Format_Format_MIN = LocationData_Format_GLOBAL;
constexpr LocationData_Format LocationData_Format_Format_MAX = LocationData_Format_MASK;
constexpr int LocationData_Format_Format_ARRAYSIZE = LocationData_Format_Format_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocationData_Format_descriptor();
template<typename T>
inline const std::string& LocationData_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationData_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationData_Format_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocationData_Format_descriptor(), enum_t_value);
}
inline bool LocationData_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocationData_Format* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocationData_Format>(
    LocationData_Format_descriptor(), name, value);
}
// ===================================================================

class LocationData_BoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.BoundingBox) */ {
 public:
  inline LocationData_BoundingBox() : LocationData_BoundingBox(nullptr) {}
  ~LocationData_BoundingBox() override;
  explicit constexpr LocationData_BoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationData_BoundingBox(const LocationData_BoundingBox& from);
  LocationData_BoundingBox(LocationData_BoundingBox&& from) noexcept
    : LocationData_BoundingBox() {
    *this = ::std::move(from);
  }

  inline LocationData_BoundingBox& operator=(const LocationData_BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationData_BoundingBox& operator=(LocationData_BoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationData_BoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationData_BoundingBox* internal_default_instance() {
    return reinterpret_cast<const LocationData_BoundingBox*>(
               &_LocationData_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LocationData_BoundingBox& a, LocationData_BoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationData_BoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationData_BoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationData_BoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationData_BoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationData_BoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationData_BoundingBox& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_BoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.LocationData.BoundingBox";
  }
  protected:
  explicit LocationData_BoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXminFieldNumber = 1,
    kYminFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // optional int32 xmin = 1;
  bool has_xmin() const;
  private:
  bool _internal_has_xmin() const;
  public:
  void clear_xmin();
  int32_t xmin() const;
  void set_xmin(int32_t value);
  private:
  int32_t _internal_xmin() const;
  void _internal_set_xmin(int32_t value);
  public:

  // optional int32 ymin = 2;
  bool has_ymin() const;
  private:
  bool _internal_has_ymin() const;
  public:
  void clear_ymin();
  int32_t ymin() const;
  void set_ymin(int32_t value);
  private:
  int32_t _internal_ymin() const;
  void _internal_set_ymin(int32_t value);
  public:

  // optional int32 width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.BoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t xmin_;
  int32_t ymin_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LocationData_RelativeBoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.RelativeBoundingBox) */ {
 public:
  inline LocationData_RelativeBoundingBox() : LocationData_RelativeBoundingBox(nullptr) {}
  ~LocationData_RelativeBoundingBox() override;
  explicit constexpr LocationData_RelativeBoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationData_RelativeBoundingBox(const LocationData_RelativeBoundingBox& from);
  LocationData_RelativeBoundingBox(LocationData_RelativeBoundingBox&& from) noexcept
    : LocationData_RelativeBoundingBox() {
    *this = ::std::move(from);
  }

  inline LocationData_RelativeBoundingBox& operator=(const LocationData_RelativeBoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationData_RelativeBoundingBox& operator=(LocationData_RelativeBoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationData_RelativeBoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationData_RelativeBoundingBox* internal_default_instance() {
    return reinterpret_cast<const LocationData_RelativeBoundingBox*>(
               &_LocationData_RelativeBoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LocationData_RelativeBoundingBox& a, LocationData_RelativeBoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationData_RelativeBoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationData_RelativeBoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationData_RelativeBoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationData_RelativeBoundingBox>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationData_RelativeBoundingBox& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationData_RelativeBoundingBox& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_RelativeBoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.LocationData.RelativeBoundingBox";
  }
  protected:
  explicit LocationData_RelativeBoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXminFieldNumber = 1,
    kYminFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // optional float xmin = 1;
  bool has_xmin() const;
  private:
  bool _internal_has_xmin() const;
  public:
  void clear_xmin();
  float xmin() const;
  void set_xmin(float value);
  private:
  float _internal_xmin() const;
  void _internal_set_xmin(float value);
  public:

  // optional float ymin = 2;
  bool has_ymin() const;
  private:
  bool _internal_has_ymin() const;
  public:
  void clear_ymin();
  float ymin() const;
  void set_ymin(float value);
  private:
  float _internal_ymin() const;
  void _internal_set_ymin(float value);
  public:

  // optional float width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional float height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.RelativeBoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float xmin_;
  float ymin_;
  float width_;
  float height_;
  friend struct ::TableStruct_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LocationData_BinaryMask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.BinaryMask) */ {
 public:
  inline LocationData_BinaryMask() : LocationData_BinaryMask(nullptr) {}
  ~LocationData_BinaryMask() override;
  explicit constexpr LocationData_BinaryMask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationData_BinaryMask(const LocationData_BinaryMask& from);
  LocationData_BinaryMask(LocationData_BinaryMask&& from) noexcept
    : LocationData_BinaryMask() {
    *this = ::std::move(from);
  }

  inline LocationData_BinaryMask& operator=(const LocationData_BinaryMask& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationData_BinaryMask& operator=(LocationData_BinaryMask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationData_BinaryMask& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationData_BinaryMask* internal_default_instance() {
    return reinterpret_cast<const LocationData_BinaryMask*>(
               &_LocationData_BinaryMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LocationData_BinaryMask& a, LocationData_BinaryMask& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationData_BinaryMask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationData_BinaryMask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationData_BinaryMask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationData_BinaryMask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationData_BinaryMask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationData_BinaryMask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_BinaryMask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.LocationData.BinaryMask";
  }
  protected:
  explicit LocationData_BinaryMask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRasterizationFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional .mediapipe.Rasterization rasterization = 3;
  bool has_rasterization() const;
  private:
  bool _internal_has_rasterization() const;
  public:
  void clear_rasterization();
  const ::mediapipe::Rasterization& rasterization() const;
  PROTOBUF_NODISCARD ::mediapipe::Rasterization* release_rasterization();
  ::mediapipe::Rasterization* mutable_rasterization();
  void set_allocated_rasterization(::mediapipe::Rasterization* rasterization);
  private:
  const ::mediapipe::Rasterization& _internal_rasterization() const;
  ::mediapipe::Rasterization* _internal_mutable_rasterization();
  public:
  void unsafe_arena_set_allocated_rasterization(
      ::mediapipe::Rasterization* rasterization);
  ::mediapipe::Rasterization* unsafe_arena_release_rasterization();

  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.BinaryMask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mediapipe::Rasterization* rasterization_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LocationData_RelativeKeypoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData.RelativeKeypoint) */ {
 public:
  inline LocationData_RelativeKeypoint() : LocationData_RelativeKeypoint(nullptr) {}
  ~LocationData_RelativeKeypoint() override;
  explicit constexpr LocationData_RelativeKeypoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationData_RelativeKeypoint(const LocationData_RelativeKeypoint& from);
  LocationData_RelativeKeypoint(LocationData_RelativeKeypoint&& from) noexcept
    : LocationData_RelativeKeypoint() {
    *this = ::std::move(from);
  }

  inline LocationData_RelativeKeypoint& operator=(const LocationData_RelativeKeypoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationData_RelativeKeypoint& operator=(LocationData_RelativeKeypoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationData_RelativeKeypoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationData_RelativeKeypoint* internal_default_instance() {
    return reinterpret_cast<const LocationData_RelativeKeypoint*>(
               &_LocationData_RelativeKeypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LocationData_RelativeKeypoint& a, LocationData_RelativeKeypoint& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationData_RelativeKeypoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationData_RelativeKeypoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationData_RelativeKeypoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationData_RelativeKeypoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationData_RelativeKeypoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationData_RelativeKeypoint& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData_RelativeKeypoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.LocationData.RelativeKeypoint";
  }
  protected:
  explicit LocationData_RelativeKeypoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeypointLabelFieldNumber = 3,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kScoreFieldNumber = 4,
  };
  // optional string keypoint_label = 3;
  bool has_keypoint_label() const;
  private:
  bool _internal_has_keypoint_label() const;
  public:
  void clear_keypoint_label();
  const std::string& keypoint_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keypoint_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keypoint_label();
  PROTOBUF_NODISCARD std::string* release_keypoint_label();
  void set_allocated_keypoint_label(std::string* keypoint_label);
  private:
  const std::string& _internal_keypoint_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keypoint_label(const std::string& value);
  std::string* _internal_mutable_keypoint_label();
  public:

  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float score = 4;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData.RelativeKeypoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keypoint_label_;
  float x_;
  float y_;
  float score_;
  friend struct ::TableStruct_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LocationData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.LocationData) */ {
 public:
  inline LocationData() : LocationData(nullptr) {}
  ~LocationData() override;
  explicit constexpr LocationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationData(const LocationData& from);
  LocationData(LocationData&& from) noexcept
    : LocationData() {
    *this = ::std::move(from);
  }

  inline LocationData& operator=(const LocationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationData& operator=(LocationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationData* internal_default_instance() {
    return reinterpret_cast<const LocationData*>(
               &_LocationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LocationData& a, LocationData& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocationData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.LocationData";
  }
  protected:
  explicit LocationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LocationData_BoundingBox BoundingBox;
  typedef LocationData_RelativeBoundingBox RelativeBoundingBox;
  typedef LocationData_BinaryMask BinaryMask;
  typedef LocationData_RelativeKeypoint RelativeKeypoint;

  typedef LocationData_Format Format;
  static constexpr Format GLOBAL =
    LocationData_Format_GLOBAL;
  static constexpr Format BOUNDING_BOX =
    LocationData_Format_BOUNDING_BOX;
  static constexpr Format RELATIVE_BOUNDING_BOX =
    LocationData_Format_RELATIVE_BOUNDING_BOX;
  static constexpr Format MASK =
    LocationData_Format_MASK;
  static inline bool Format_IsValid(int value) {
    return LocationData_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    LocationData_Format_Format_MIN;
  static constexpr Format Format_MAX =
    LocationData_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    LocationData_Format_Format_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Format_descriptor() {
    return LocationData_Format_descriptor();
  }
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return LocationData_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return LocationData_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRelativeKeypointsFieldNumber = 5,
    kBoundingBoxFieldNumber = 2,
    kRelativeBoundingBoxFieldNumber = 3,
    kMaskFieldNumber = 4,
    kFormatFieldNumber = 1,
  };
  // repeated .mediapipe.LocationData.RelativeKeypoint relative_keypoints = 5;
  int relative_keypoints_size() const;
  private:
  int _internal_relative_keypoints_size() const;
  public:
  void clear_relative_keypoints();
  ::mediapipe::LocationData_RelativeKeypoint* mutable_relative_keypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >*
      mutable_relative_keypoints();
  private:
  const ::mediapipe::LocationData_RelativeKeypoint& _internal_relative_keypoints(int index) const;
  ::mediapipe::LocationData_RelativeKeypoint* _internal_add_relative_keypoints();
  public:
  const ::mediapipe::LocationData_RelativeKeypoint& relative_keypoints(int index) const;
  ::mediapipe::LocationData_RelativeKeypoint* add_relative_keypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >&
      relative_keypoints() const;

  // optional .mediapipe.LocationData.BoundingBox bounding_box = 2;
  bool has_bounding_box() const;
  private:
  bool _internal_has_bounding_box() const;
  public:
  void clear_bounding_box();
  const ::mediapipe::LocationData_BoundingBox& bounding_box() const;
  PROTOBUF_NODISCARD ::mediapipe::LocationData_BoundingBox* release_bounding_box();
  ::mediapipe::LocationData_BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::mediapipe::LocationData_BoundingBox* bounding_box);
  private:
  const ::mediapipe::LocationData_BoundingBox& _internal_bounding_box() const;
  ::mediapipe::LocationData_BoundingBox* _internal_mutable_bounding_box();
  public:
  void unsafe_arena_set_allocated_bounding_box(
      ::mediapipe::LocationData_BoundingBox* bounding_box);
  ::mediapipe::LocationData_BoundingBox* unsafe_arena_release_bounding_box();

  // optional .mediapipe.LocationData.RelativeBoundingBox relative_bounding_box = 3;
  bool has_relative_bounding_box() const;
  private:
  bool _internal_has_relative_bounding_box() const;
  public:
  void clear_relative_bounding_box();
  const ::mediapipe::LocationData_RelativeBoundingBox& relative_bounding_box() const;
  PROTOBUF_NODISCARD ::mediapipe::LocationData_RelativeBoundingBox* release_relative_bounding_box();
  ::mediapipe::LocationData_RelativeBoundingBox* mutable_relative_bounding_box();
  void set_allocated_relative_bounding_box(::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box);
  private:
  const ::mediapipe::LocationData_RelativeBoundingBox& _internal_relative_bounding_box() const;
  ::mediapipe::LocationData_RelativeBoundingBox* _internal_mutable_relative_bounding_box();
  public:
  void unsafe_arena_set_allocated_relative_bounding_box(
      ::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box);
  ::mediapipe::LocationData_RelativeBoundingBox* unsafe_arena_release_relative_bounding_box();

  // optional .mediapipe.LocationData.BinaryMask mask = 4;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  const ::mediapipe::LocationData_BinaryMask& mask() const;
  PROTOBUF_NODISCARD ::mediapipe::LocationData_BinaryMask* release_mask();
  ::mediapipe::LocationData_BinaryMask* mutable_mask();
  void set_allocated_mask(::mediapipe::LocationData_BinaryMask* mask);
  private:
  const ::mediapipe::LocationData_BinaryMask& _internal_mask() const;
  ::mediapipe::LocationData_BinaryMask* _internal_mutable_mask();
  public:
  void unsafe_arena_set_allocated_mask(
      ::mediapipe::LocationData_BinaryMask* mask);
  ::mediapipe::LocationData_BinaryMask* unsafe_arena_release_mask();

  // optional .mediapipe.LocationData.Format format = 1;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::mediapipe::LocationData_Format format() const;
  void set_format(::mediapipe::LocationData_Format value);
  private:
  ::mediapipe::LocationData_Format _internal_format() const;
  void _internal_set_format(::mediapipe::LocationData_Format value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.LocationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint > relative_keypoints_;
  ::mediapipe::LocationData_BoundingBox* bounding_box_;
  ::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box_;
  ::mediapipe::LocationData_BinaryMask* mask_;
  int format_;
  friend struct ::TableStruct_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LocationData_BoundingBox

// optional int32 xmin = 1;
inline bool LocationData_BoundingBox::_internal_has_xmin() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocationData_BoundingBox::has_xmin() const {
  return _internal_has_xmin();
}
inline void LocationData_BoundingBox::clear_xmin() {
  xmin_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t LocationData_BoundingBox::_internal_xmin() const {
  return xmin_;
}
inline int32_t LocationData_BoundingBox::xmin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.xmin)
  return _internal_xmin();
}
inline void LocationData_BoundingBox::_internal_set_xmin(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  xmin_ = value;
}
inline void LocationData_BoundingBox::set_xmin(int32_t value) {
  _internal_set_xmin(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.xmin)
}

// optional int32 ymin = 2;
inline bool LocationData_BoundingBox::_internal_has_ymin() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationData_BoundingBox::has_ymin() const {
  return _internal_has_ymin();
}
inline void LocationData_BoundingBox::clear_ymin() {
  ymin_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t LocationData_BoundingBox::_internal_ymin() const {
  return ymin_;
}
inline int32_t LocationData_BoundingBox::ymin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.ymin)
  return _internal_ymin();
}
inline void LocationData_BoundingBox::_internal_set_ymin(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  ymin_ = value;
}
inline void LocationData_BoundingBox::set_ymin(int32_t value) {
  _internal_set_ymin(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.ymin)
}

// optional int32 width = 3;
inline bool LocationData_BoundingBox::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocationData_BoundingBox::has_width() const {
  return _internal_has_width();
}
inline void LocationData_BoundingBox::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t LocationData_BoundingBox::_internal_width() const {
  return width_;
}
inline int32_t LocationData_BoundingBox::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.width)
  return _internal_width();
}
inline void LocationData_BoundingBox::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void LocationData_BoundingBox::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.width)
}

// optional int32 height = 4;
inline bool LocationData_BoundingBox::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocationData_BoundingBox::has_height() const {
  return _internal_has_height();
}
inline void LocationData_BoundingBox::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t LocationData_BoundingBox::_internal_height() const {
  return height_;
}
inline int32_t LocationData_BoundingBox::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BoundingBox.height)
  return _internal_height();
}
inline void LocationData_BoundingBox::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
}
inline void LocationData_BoundingBox::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BoundingBox.height)
}

// -------------------------------------------------------------------

// LocationData_RelativeBoundingBox

// optional float xmin = 1;
inline bool LocationData_RelativeBoundingBox::_internal_has_xmin() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocationData_RelativeBoundingBox::has_xmin() const {
  return _internal_has_xmin();
}
inline void LocationData_RelativeBoundingBox::clear_xmin() {
  xmin_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float LocationData_RelativeBoundingBox::_internal_xmin() const {
  return xmin_;
}
inline float LocationData_RelativeBoundingBox::xmin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.xmin)
  return _internal_xmin();
}
inline void LocationData_RelativeBoundingBox::_internal_set_xmin(float value) {
  _has_bits_[0] |= 0x00000001u;
  xmin_ = value;
}
inline void LocationData_RelativeBoundingBox::set_xmin(float value) {
  _internal_set_xmin(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.xmin)
}

// optional float ymin = 2;
inline bool LocationData_RelativeBoundingBox::_internal_has_ymin() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationData_RelativeBoundingBox::has_ymin() const {
  return _internal_has_ymin();
}
inline void LocationData_RelativeBoundingBox::clear_ymin() {
  ymin_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float LocationData_RelativeBoundingBox::_internal_ymin() const {
  return ymin_;
}
inline float LocationData_RelativeBoundingBox::ymin() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.ymin)
  return _internal_ymin();
}
inline void LocationData_RelativeBoundingBox::_internal_set_ymin(float value) {
  _has_bits_[0] |= 0x00000002u;
  ymin_ = value;
}
inline void LocationData_RelativeBoundingBox::set_ymin(float value) {
  _internal_set_ymin(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.ymin)
}

// optional float width = 3;
inline bool LocationData_RelativeBoundingBox::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocationData_RelativeBoundingBox::has_width() const {
  return _internal_has_width();
}
inline void LocationData_RelativeBoundingBox::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LocationData_RelativeBoundingBox::_internal_width() const {
  return width_;
}
inline float LocationData_RelativeBoundingBox::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.width)
  return _internal_width();
}
inline void LocationData_RelativeBoundingBox::_internal_set_width(float value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void LocationData_RelativeBoundingBox::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.width)
}

// optional float height = 4;
inline bool LocationData_RelativeBoundingBox::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocationData_RelativeBoundingBox::has_height() const {
  return _internal_has_height();
}
inline void LocationData_RelativeBoundingBox::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float LocationData_RelativeBoundingBox::_internal_height() const {
  return height_;
}
inline float LocationData_RelativeBoundingBox::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeBoundingBox.height)
  return _internal_height();
}
inline void LocationData_RelativeBoundingBox::_internal_set_height(float value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
}
inline void LocationData_RelativeBoundingBox::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeBoundingBox.height)
}

// -------------------------------------------------------------------

// LocationData_BinaryMask

// optional int32 width = 1;
inline bool LocationData_BinaryMask::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationData_BinaryMask::has_width() const {
  return _internal_has_width();
}
inline void LocationData_BinaryMask::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t LocationData_BinaryMask::_internal_width() const {
  return width_;
}
inline int32_t LocationData_BinaryMask::width() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BinaryMask.width)
  return _internal_width();
}
inline void LocationData_BinaryMask::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
}
inline void LocationData_BinaryMask::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BinaryMask.width)
}

// optional int32 height = 2;
inline bool LocationData_BinaryMask::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocationData_BinaryMask::has_height() const {
  return _internal_has_height();
}
inline void LocationData_BinaryMask::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t LocationData_BinaryMask::_internal_height() const {
  return height_;
}
inline int32_t LocationData_BinaryMask::height() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BinaryMask.height)
  return _internal_height();
}
inline void LocationData_BinaryMask::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  height_ = value;
}
inline void LocationData_BinaryMask::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.BinaryMask.height)
}

// optional .mediapipe.Rasterization rasterization = 3;
inline bool LocationData_BinaryMask::_internal_has_rasterization() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rasterization_ != nullptr);
  return value;
}
inline bool LocationData_BinaryMask::has_rasterization() const {
  return _internal_has_rasterization();
}
inline const ::mediapipe::Rasterization& LocationData_BinaryMask::_internal_rasterization() const {
  const ::mediapipe::Rasterization* p = rasterization_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::Rasterization&>(
      ::mediapipe::_Rasterization_default_instance_);
}
inline const ::mediapipe::Rasterization& LocationData_BinaryMask::rasterization() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.BinaryMask.rasterization)
  return _internal_rasterization();
}
inline void LocationData_BinaryMask::unsafe_arena_set_allocated_rasterization(
    ::mediapipe::Rasterization* rasterization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rasterization_);
  }
  rasterization_ = rasterization;
  if (rasterization) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.LocationData.BinaryMask.rasterization)
}
inline ::mediapipe::Rasterization* LocationData_BinaryMask::release_rasterization() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::Rasterization* temp = rasterization_;
  rasterization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mediapipe::Rasterization* LocationData_BinaryMask::unsafe_arena_release_rasterization() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.BinaryMask.rasterization)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::Rasterization* temp = rasterization_;
  rasterization_ = nullptr;
  return temp;
}
inline ::mediapipe::Rasterization* LocationData_BinaryMask::_internal_mutable_rasterization() {
  _has_bits_[0] |= 0x00000001u;
  if (rasterization_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::Rasterization>(GetArenaForAllocation());
    rasterization_ = p;
  }
  return rasterization_;
}
inline ::mediapipe::Rasterization* LocationData_BinaryMask::mutable_rasterization() {
  ::mediapipe::Rasterization* _msg = _internal_mutable_rasterization();
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.BinaryMask.rasterization)
  return _msg;
}
inline void LocationData_BinaryMask::set_allocated_rasterization(::mediapipe::Rasterization* rasterization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rasterization_);
  }
  if (rasterization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rasterization));
    if (message_arena != submessage_arena) {
      rasterization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rasterization, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rasterization_ = rasterization;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.BinaryMask.rasterization)
}

// -------------------------------------------------------------------

// LocationData_RelativeKeypoint

// optional float x = 1;
inline bool LocationData_RelativeKeypoint::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationData_RelativeKeypoint::has_x() const {
  return _internal_has_x();
}
inline void LocationData_RelativeKeypoint::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float LocationData_RelativeKeypoint::_internal_x() const {
  return x_;
}
inline float LocationData_RelativeKeypoint::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.x)
  return _internal_x();
}
inline void LocationData_RelativeKeypoint::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  x_ = value;
}
inline void LocationData_RelativeKeypoint::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.x)
}

// optional float y = 2;
inline bool LocationData_RelativeKeypoint::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocationData_RelativeKeypoint::has_y() const {
  return _internal_has_y();
}
inline void LocationData_RelativeKeypoint::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LocationData_RelativeKeypoint::_internal_y() const {
  return y_;
}
inline float LocationData_RelativeKeypoint::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.y)
  return _internal_y();
}
inline void LocationData_RelativeKeypoint::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  y_ = value;
}
inline void LocationData_RelativeKeypoint::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.y)
}

// optional string keypoint_label = 3;
inline bool LocationData_RelativeKeypoint::_internal_has_keypoint_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocationData_RelativeKeypoint::has_keypoint_label() const {
  return _internal_has_keypoint_label();
}
inline void LocationData_RelativeKeypoint::clear_keypoint_label() {
  keypoint_label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocationData_RelativeKeypoint::keypoint_label() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
  return _internal_keypoint_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocationData_RelativeKeypoint::set_keypoint_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 keypoint_label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}
inline std::string* LocationData_RelativeKeypoint::mutable_keypoint_label() {
  std::string* _s = _internal_mutable_keypoint_label();
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
  return _s;
}
inline const std::string& LocationData_RelativeKeypoint::_internal_keypoint_label() const {
  return keypoint_label_.Get();
}
inline void LocationData_RelativeKeypoint::_internal_set_keypoint_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  keypoint_label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocationData_RelativeKeypoint::_internal_mutable_keypoint_label() {
  _has_bits_[0] |= 0x00000001u;
  return keypoint_label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocationData_RelativeKeypoint::release_keypoint_label() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
  if (!_internal_has_keypoint_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = keypoint_label_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keypoint_label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keypoint_label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LocationData_RelativeKeypoint::set_allocated_keypoint_label(std::string* keypoint_label) {
  if (keypoint_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keypoint_label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keypoint_label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (keypoint_label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    keypoint_label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.RelativeKeypoint.keypoint_label)
}

// optional float score = 4;
inline bool LocationData_RelativeKeypoint::_internal_has_score() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocationData_RelativeKeypoint::has_score() const {
  return _internal_has_score();
}
inline void LocationData_RelativeKeypoint::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float LocationData_RelativeKeypoint::_internal_score() const {
  return score_;
}
inline float LocationData_RelativeKeypoint::score() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.RelativeKeypoint.score)
  return _internal_score();
}
inline void LocationData_RelativeKeypoint::_internal_set_score(float value) {
  _has_bits_[0] |= 0x00000008u;
  score_ = value;
}
inline void LocationData_RelativeKeypoint::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.RelativeKeypoint.score)
}

// -------------------------------------------------------------------

// LocationData

// optional .mediapipe.LocationData.Format format = 1;
inline bool LocationData::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocationData::has_format() const {
  return _internal_has_format();
}
inline void LocationData::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::mediapipe::LocationData_Format LocationData::_internal_format() const {
  return static_cast< ::mediapipe::LocationData_Format >(format_);
}
inline ::mediapipe::LocationData_Format LocationData::format() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.format)
  return _internal_format();
}
inline void LocationData::_internal_set_format(::mediapipe::LocationData_Format value) {
  assert(::mediapipe::LocationData_Format_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  format_ = value;
}
inline void LocationData::set_format(::mediapipe::LocationData_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:mediapipe.LocationData.format)
}

// optional .mediapipe.LocationData.BoundingBox bounding_box = 2;
inline bool LocationData::_internal_has_bounding_box() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bounding_box_ != nullptr);
  return value;
}
inline bool LocationData::has_bounding_box() const {
  return _internal_has_bounding_box();
}
inline void LocationData::clear_bounding_box() {
  if (bounding_box_ != nullptr) bounding_box_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mediapipe::LocationData_BoundingBox& LocationData::_internal_bounding_box() const {
  const ::mediapipe::LocationData_BoundingBox* p = bounding_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::LocationData_BoundingBox&>(
      ::mediapipe::_LocationData_BoundingBox_default_instance_);
}
inline const ::mediapipe::LocationData_BoundingBox& LocationData::bounding_box() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.bounding_box)
  return _internal_bounding_box();
}
inline void LocationData::unsafe_arena_set_allocated_bounding_box(
    ::mediapipe::LocationData_BoundingBox* bounding_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bounding_box_);
  }
  bounding_box_ = bounding_box;
  if (bounding_box) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.LocationData.bounding_box)
}
inline ::mediapipe::LocationData_BoundingBox* LocationData::release_bounding_box() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::LocationData_BoundingBox* temp = bounding_box_;
  bounding_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mediapipe::LocationData_BoundingBox* LocationData::unsafe_arena_release_bounding_box() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.bounding_box)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::LocationData_BoundingBox* temp = bounding_box_;
  bounding_box_ = nullptr;
  return temp;
}
inline ::mediapipe::LocationData_BoundingBox* LocationData::_internal_mutable_bounding_box() {
  _has_bits_[0] |= 0x00000001u;
  if (bounding_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData_BoundingBox>(GetArenaForAllocation());
    bounding_box_ = p;
  }
  return bounding_box_;
}
inline ::mediapipe::LocationData_BoundingBox* LocationData::mutable_bounding_box() {
  ::mediapipe::LocationData_BoundingBox* _msg = _internal_mutable_bounding_box();
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.bounding_box)
  return _msg;
}
inline void LocationData::set_allocated_bounding_box(::mediapipe::LocationData_BoundingBox* bounding_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mediapipe::LocationData_BoundingBox>::GetOwningArena(bounding_box);
    if (message_arena != submessage_arena) {
      bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.bounding_box)
}

// optional .mediapipe.LocationData.RelativeBoundingBox relative_bounding_box = 3;
inline bool LocationData::_internal_has_relative_bounding_box() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || relative_bounding_box_ != nullptr);
  return value;
}
inline bool LocationData::has_relative_bounding_box() const {
  return _internal_has_relative_bounding_box();
}
inline void LocationData::clear_relative_bounding_box() {
  if (relative_bounding_box_ != nullptr) relative_bounding_box_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mediapipe::LocationData_RelativeBoundingBox& LocationData::_internal_relative_bounding_box() const {
  const ::mediapipe::LocationData_RelativeBoundingBox* p = relative_bounding_box_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::LocationData_RelativeBoundingBox&>(
      ::mediapipe::_LocationData_RelativeBoundingBox_default_instance_);
}
inline const ::mediapipe::LocationData_RelativeBoundingBox& LocationData::relative_bounding_box() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.relative_bounding_box)
  return _internal_relative_bounding_box();
}
inline void LocationData::unsafe_arena_set_allocated_relative_bounding_box(
    ::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relative_bounding_box_);
  }
  relative_bounding_box_ = relative_bounding_box;
  if (relative_bounding_box) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.LocationData.relative_bounding_box)
}
inline ::mediapipe::LocationData_RelativeBoundingBox* LocationData::release_relative_bounding_box() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::LocationData_RelativeBoundingBox* temp = relative_bounding_box_;
  relative_bounding_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mediapipe::LocationData_RelativeBoundingBox* LocationData::unsafe_arena_release_relative_bounding_box() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.relative_bounding_box)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::LocationData_RelativeBoundingBox* temp = relative_bounding_box_;
  relative_bounding_box_ = nullptr;
  return temp;
}
inline ::mediapipe::LocationData_RelativeBoundingBox* LocationData::_internal_mutable_relative_bounding_box() {
  _has_bits_[0] |= 0x00000002u;
  if (relative_bounding_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData_RelativeBoundingBox>(GetArenaForAllocation());
    relative_bounding_box_ = p;
  }
  return relative_bounding_box_;
}
inline ::mediapipe::LocationData_RelativeBoundingBox* LocationData::mutable_relative_bounding_box() {
  ::mediapipe::LocationData_RelativeBoundingBox* _msg = _internal_mutable_relative_bounding_box();
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.relative_bounding_box)
  return _msg;
}
inline void LocationData::set_allocated_relative_bounding_box(::mediapipe::LocationData_RelativeBoundingBox* relative_bounding_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete relative_bounding_box_;
  }
  if (relative_bounding_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mediapipe::LocationData_RelativeBoundingBox>::GetOwningArena(relative_bounding_box);
    if (message_arena != submessage_arena) {
      relative_bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relative_bounding_box, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  relative_bounding_box_ = relative_bounding_box;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.relative_bounding_box)
}

// optional .mediapipe.LocationData.BinaryMask mask = 4;
inline bool LocationData::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || mask_ != nullptr);
  return value;
}
inline bool LocationData::has_mask() const {
  return _internal_has_mask();
}
inline void LocationData::clear_mask() {
  if (mask_ != nullptr) mask_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mediapipe::LocationData_BinaryMask& LocationData::_internal_mask() const {
  const ::mediapipe::LocationData_BinaryMask* p = mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::LocationData_BinaryMask&>(
      ::mediapipe::_LocationData_BinaryMask_default_instance_);
}
inline const ::mediapipe::LocationData_BinaryMask& LocationData::mask() const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.mask)
  return _internal_mask();
}
inline void LocationData::unsafe_arena_set_allocated_mask(
    ::mediapipe::LocationData_BinaryMask* mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mask_);
  }
  mask_ = mask;
  if (mask) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.LocationData.mask)
}
inline ::mediapipe::LocationData_BinaryMask* LocationData::release_mask() {
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::LocationData_BinaryMask* temp = mask_;
  mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mediapipe::LocationData_BinaryMask* LocationData::unsafe_arena_release_mask() {
  // @@protoc_insertion_point(field_release:mediapipe.LocationData.mask)
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::LocationData_BinaryMask* temp = mask_;
  mask_ = nullptr;
  return temp;
}
inline ::mediapipe::LocationData_BinaryMask* LocationData::_internal_mutable_mask() {
  _has_bits_[0] |= 0x00000004u;
  if (mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::LocationData_BinaryMask>(GetArenaForAllocation());
    mask_ = p;
  }
  return mask_;
}
inline ::mediapipe::LocationData_BinaryMask* LocationData::mutable_mask() {
  ::mediapipe::LocationData_BinaryMask* _msg = _internal_mutable_mask();
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.mask)
  return _msg;
}
inline void LocationData::set_allocated_mask(::mediapipe::LocationData_BinaryMask* mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mask_;
  }
  if (mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::mediapipe::LocationData_BinaryMask>::GetOwningArena(mask);
    if (message_arena != submessage_arena) {
      mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mask, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  mask_ = mask;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.LocationData.mask)
}

// repeated .mediapipe.LocationData.RelativeKeypoint relative_keypoints = 5;
inline int LocationData::_internal_relative_keypoints_size() const {
  return relative_keypoints_.size();
}
inline int LocationData::relative_keypoints_size() const {
  return _internal_relative_keypoints_size();
}
inline void LocationData::clear_relative_keypoints() {
  relative_keypoints_.Clear();
}
inline ::mediapipe::LocationData_RelativeKeypoint* LocationData::mutable_relative_keypoints(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.LocationData.relative_keypoints)
  return relative_keypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >*
LocationData::mutable_relative_keypoints() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.LocationData.relative_keypoints)
  return &relative_keypoints_;
}
inline const ::mediapipe::LocationData_RelativeKeypoint& LocationData::_internal_relative_keypoints(int index) const {
  return relative_keypoints_.Get(index);
}
inline const ::mediapipe::LocationData_RelativeKeypoint& LocationData::relative_keypoints(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.LocationData.relative_keypoints)
  return _internal_relative_keypoints(index);
}
inline ::mediapipe::LocationData_RelativeKeypoint* LocationData::_internal_add_relative_keypoints() {
  return relative_keypoints_.Add();
}
inline ::mediapipe::LocationData_RelativeKeypoint* LocationData::add_relative_keypoints() {
  ::mediapipe::LocationData_RelativeKeypoint* _add = _internal_add_relative_keypoints();
  // @@protoc_insertion_point(field_add:mediapipe.LocationData.relative_keypoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::LocationData_RelativeKeypoint >&
LocationData::relative_keypoints() const {
  // @@protoc_insertion_point(field_list:mediapipe.LocationData.relative_keypoints)
  return relative_keypoints_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediapipe

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mediapipe::LocationData_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::LocationData_Format>() {
  return ::mediapipe::LocationData_Format_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mediapipe_2fframework_2fformats_2flocation_5fdata_2eproto
